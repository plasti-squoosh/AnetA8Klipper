[gcode_macro START_PRINT1] # Gcode to insert into START of slicer just enter START_PRINT1
gcode:
    {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}
    # Heat bed for probing
    M190 S{BED_TEMP}
    # Use absolute coordinates
    G90
    # Home the printer
    G28
    #Preheat extruder
    M109 S150
    # If you are using QGL:
    #QUAD_GANTRY_LEVEL
    #G28 Z

    # If you are using Z-Tilt:
    #Z_TILT_ADJUST

    # If you are generating a new bed mesh:
    BED_MESH_CALIBRATE ADAPTIVE=1
    ## NOTE:    The adaptive meshing feature requires exclude_object     ##
    ##      and may require 'Label Objects' to be enabled in the slicer  ##
    ##           To mesh without it just use BED_MESH_CALIBRATE          ##

    # If you are loading an existing mesh:
    #BED_MESH_PROFILE LOAD=default

    # Move the nozzle near the bed
    G1 Z5 F3000
    # Set and wait for nozzle to reach printing temperature
    M109 S{EXTRUDER_TEMP}

    PURGE_LINE
    # SET_VELOCITY LIMIT 110
    # Start printing!


# ================================================================================
# GCode Macro: END_PRINT
# Add END_PRINT in your slicers ending script
# ================================================================================
[gcode_macro END_PRINT]
gcode:
    G1 Y190 F1500; bring Y up front 
    G10 ; retract
    G91; Relative Positioning
    G1 Z+10; Move Z up so it doesn't hit anything
    G1 E-2 F300; Retract-10
    G90; Absolute Positioning
    G1 X10 Y200 F2000; Move to X10, Y220
    M104 S0; Turn off Extrude (set it to 0)
    M140 S0; Turn off Bed (set it to 0)
    M106 S0; turn off cooling fan
    M84; Disable steppers


[bed_mesh] # Gcode to make a bed mesh
speed: 150
horizontal_move_z: 5
mesh_min: 20, 5
mesh_max: 215, 215
probe_count: 6, 6
mesh_pps: 3, 3
adaptive_margin: 0
fade_start: 1
fade_end: 10
fade_target:0

[bed_screws] # location of bed screws
screw1:  -11, 11
screw1_name: Front Left
screw2: 179, 11
screw2_name: Front Right
screw3: -11, 215
screw3_name: Back Left
screw4: 179, 215
Screw4_name: Back Right

[screws_tilt_adjust] #location of bed screws for the BED_SCREW_CALIBRATE command
screw1:  -11, 11
screw1_name: Front Left
screw2: 179, 11
screw2_name: Front Right
screw3: -11, 215
screw3_name: Back Left
screw4: 179, 215
Screw4_name: Back Right
screw_thread: CW-M3

[respond] # Necessary

[save_variables] # Need to have variables.cfg file 
filename: ~/printer_data/variables.cfg # UPDATE THIS FOR YOUR PATH!!!

[gcode_macro mesh_leveling] # Redundant?
gcode: 
       #Set extruder and bed temperature 
       M190 S65 
             # Home all axis 
       G28 
       #Start probing 
       BED_MESH_CALIBRATE PROFILE=default METHOD=automatic 
       #Turn off heaters 
       TURN_OFF_HEATERS

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BED_MESH_CALIBRATE_BASE
; gcode parameters
variable_parameter_AREA_START : 0,0
variable_parameter_AREA_END : 180,180
; the clearance between print area and probe area 
variable_mesh_area_offset : 5.0
; number of sample per probe point
variable_probe_samples : 2
; minimum probe count
variable_min_probe_count : 4
; scale up the probe count, should be 1.0 ~ < variable_max_probe_count/variable_min_probe_count
variable_probe_count_scale_factor : 1.0
; enable preference index
variable_enable_reference_index : True
gcode:
    {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
    # Heat bed for probing
    M190 S{BED_TEMP}
    {% if params.AREA_START and params.AREA_END %}
        {% set bedMeshConfig = printer["configfile"].config["bed_mesh"] %}
        {% set safe_min_x = bedMeshConfig.mesh_min.split(",")[0]|float %}
        {% set safe_min_y = bedMeshConfig.mesh_min.split(",")[1]|float %}
        {% set safe_max_x = bedMeshConfig.mesh_max.split(",")[0]|float %}
        {% set safe_max_y = bedMeshConfig.mesh_max.split(",")[1]|float %}

        {% set area_min_x = params.AREA_START.split(",")[0]|float %}
	{% set area_min_y = params.AREA_START.split(",")[1]|float %}
	{% set area_max_x = params.AREA_END.split(",")[0]|float %}
	{% set area_max_y = params.AREA_END.split(",")[1]|float %}

	{% if bedMeshConfig.probe_count.split(",")|length == 2 %}
            {% set meshPointX = bedMeshConfig.probe_count.split(",")[0]|int %}
            {% set meshPointY = bedMeshConfig.probe_count.split(",")[1]|int %}
        {% else %}
            {% set meshPointX = bedMeshConfig.probe_count.split(",")[0]|int %}
            {% set meshPointY = bedMeshConfig.probe_count.split(",")[0]|int %}
        {% endif %}

	{% set meshMaxPointX = meshPointX %}
	{% set meshMaxPointY = meshPointY %}


        {% if (area_min_x < area_max_x) and (area_min_y < area_max_y) %}
            {% if area_min_x - mesh_area_offset >=  safe_min_x %}
                {% set area_min_x = area_min_x - mesh_area_offset %}
            {% else %}
                {% set area_min_x = safe_min_x %}
            {% endif %}

            {% if area_min_y - mesh_area_offset >=  safe_min_y %}
                {% set area_min_y = area_min_y - mesh_area_offset %}
            {% else %}
                {% set area_min_y = safe_min_y %}
            {% endif %}

            {% if area_max_x + mesh_area_offset <=  safe_max_x %}
                {% set area_max_x = area_max_x + mesh_area_offset %}
            {% else %}
                {% set area_max_x = safe_max_x %}
            {% endif %}

            {% if area_max_y + mesh_area_offset <=  safe_max_y %}
                {% set area_max_y = area_max_y + mesh_area_offset %}
            {% else %}
                {% set area_max_y = safe_max_y %}
            {% endif %}

            {% set meshPointX = (meshPointX * (area_max_x - area_min_x) / (safe_max_x - safe_min_x) * probe_count_scale_factor)|round(0)|int %}
            {% if meshPointX < min_probe_count %}
                {% set meshPointX = min_probe_count %}
            {% endif %}
	    {% if meshPointX > meshMaxPointX %}
                {% set meshPointX = meshMaxPointX %}
            {% endif %}

            {% set meshPointY = (meshPointY * (area_max_y -area_min_y ) / (safe_max_y - safe_min_y) * probe_count_scale_factor )|round(0)|int %}
            {% if meshPointY < min_probe_count %}
                {% set meshPointY = min_probe_count %}
            {% endif %}
	    {% if meshPointY > meshMaxPointY %}
                {% set meshPointY = meshMaxPointY %}
            {% endif %}

            {% set algorithm = "bicubic" %}
	    {% if "algorithm" in bedMeshConfig %}
	        {% set algorithm = bedMeshConfig.algorithm %}
            {% endif %}
            {% if meshPointX >=7 or meshPointY >=7 %}
                {% set algorithm = "bicubic" %}
            {% endif %}

            {% if enable_reference_index %}
                {% set referenceIndex = (meshPointX * meshPointY / 2 - 1 )|round(0)|int %}
                BED_MESH_CALIBRATE_BASE mesh_min={area_min_x},{area_min_y} mesh_max={area_max_x},{area_max_y} probe_count={meshPointX},{meshPointY} samples={probe_samples|int} algorithm={algorithm} relative_reference_index={referenceIndex}
            {% else %}
                BED_MESH_CALIBRATE_BASE mesh_min={area_min_x},{area_min_y} mesh_max={area_max_x},{area_max_y} probe_count={meshPointX},{meshPointY} samples={probe_samples|int} algorithm={algorithm}
            {% endif %}
        {% else %}
            BED_MESH_CALIBRATE_BASE
        {% endif %}
    {% else %}
        BED_MESH_CALIBRATE_BASE
    {% endif %}

[gcode_macro G29]
gcode:
 BED_MESH_CALIBRATE
 G1 X151 Y115 Z5 F15000

[idle_timeout]
gcode:
    TURN_OFF_HEATERS
    M104 S0
    M140 S0
    M107
    M84
#   A list of G-Code commands to execute on an idle timeout. See
#   docs/Command_Templates.md for G-Code format. The default is to run
#   "TURN_OFF_HEATERS" and "M84".
timeout: 600
#   Idle time (in seconds) to wait before running the above G-Code
#   commands. The default is 600 seconds.


[gcode_macro check_macro_docs]
description: Lists macros lacking proper documentation.
  Usage: CHECK_MACRO_DOCS [USAGE=<0|1>] [HIDDEN=<1|0>] [RENAMED=<1|0>]
gcode:
  {% set USAGE = params.USAGE|default(0)|int %}
  {% set HIDDEN = params.HIDDEN|default(0)|int %}
  {% set RENAMED = params.RENAMED|default(0)|int %}
  {% set output = [] %}
  {%set config = printer.configfile.config %}
  {% for k in config|sort %}
    {% if k.startswith("gcode_macro") %}
      {% set name = k.split()[1] %}
      {% set desc = config[k].description|default("") %}
      {% set is_renamed = config[k].rename_existing|default("") %}
      {% if (not desc or (USAGE and not "Usage: "~name.upper() in desc)) and
             (HIDDEN or not name.startswith('_')) and (RENAMED or is_renamed) %}
        {% set dummy = output.append("%s&nbsp;%s: missing %s."
           | format("*" if is_renamed else "&nbsp;", name,
                    "description" if not desc else "usage")) %}
      {% endif %}
    {% endif %}
  {% endfor %}
  {action_respond_info(output|join("\n"))}

# The below macro is a lightly edited version of the one found here:
# https://klipper.discourse.group/t/example-search-printer-objects/164
[gcode_macro listvars]
description: Lists per-macro variables with a name containing SEARCH. This is 
  useful for debugging macros by allowing you to probe printer state. Be very
  careful, however, as an overly broad SEARCH parameter can take a long time
  to process and potentially hang or crash klipper.
  Usage: LISTVARS SEARCH=<search_string>
gcode:

  {% if 'SEARCH' not in params and 'S' not in params %}
    { action_raise_error("Must provide a SEARCH parameter.") }
  {% endif %}
  {% set SEARCH = params.SEARCH|default(params.S)|lower %}
  {% set ns = namespace() %}
  {% set output = [] %}
  {% for item in printer %}
    {% if item is not string %}
      {% set ns.path = ['printer', "[%s]" % (item|string), ''] %}
    {% elif ' ' in item %}
      {% set ns.path = ['printer', "['%s']" % (item), ''] %}
    {% else %}
      {% set ns.path = ['printer.', item, ''] %}
    {% endif %}

    {% if SEARCH in ns.path|lower %}
      {% set dummy = output.append(ns.path|join) %}
    {% endif %}

    {% if printer[item].items() %}
      {% for childkey, child in printer[item].items() recursive %}
          {% set ns.path = ns.path[:loop.depth|int + 1] %}
          {% if childkey is not string %}
            {% set null = ns.path.append("[%s]" % (childkey|string)) %}
          {% elif ' ' in childkey %}
            {% set null = ns.path.append("['%s']" % (childkey)) %}
          {% else %}
            {% set null = ns.path.append(".%s" % (childkey)) %}
          {% endif %}

          {% if child is mapping  %}
            {loop(child.items())}
          {% else %}
            {% if SEARCH in ns.path|lower %}
              {% set dummy = output.append("%s : %s" % (ns.path|join, child)) %}
            {% endif %}
          {% endif %}
        {% endfor %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output|join("\n")) }

[gcode_macro list_macros]
description: Lists registered macros (and optionally show variable state).
  Usage: LISTVARS SEARCH=<search_string> VARS=<0|1> SILENT=<0|1>
variable_macros: {}
gcode:
  # Load the config state once and save it.
  {% if not macros %}
    {% set renames = {} %}
    {% for k in printer.configfile.config %}
      {% if k.lower().startswith("gcode_macro") and
            printer.configfile.config[k].rename_existing %}
          {% set name = k.split(None, 1)[1] | lower %}
          {% set dummy = renames.__setitem__(name,
                          [printer.configfile.config[k].rename_existing|lower] +
                            renames[name]|default([])) %}
      {% endif %}
    {% endfor %}
    {% for k in printer %}
      {% if k.lower().startswith("gcode_macro") %}
        {% set name = k.split(None, 1)[1] | lower %}
        {% set dummy = macros.__setitem__(name, renames[name]|default([])) %}
      {% endif %}
    {% endfor %}
  {% endif %}

  {% if params.SILENT|default(0)|int == 0 %}
    _LIST_MACROS_DISPLAY {rawparams}
  {% endif %}

[gcode_macro _list_macros_display]
gcode:
  {% set SEARCH = params.SEARCH | default(params.S) | default("") | lower %}
  {% set VARS = params.VARS | default(params.V) | default(0) | int != 0 %}

  {% set macros = printer["gcode_macro list_macros"].macros %}
  {% set output = [] %}
  {% for k in macros %}
    {% if SEARCH in k | lower %}
      {% set line = k ~ ((" (renames: %s)" % (macros[k]|join(","))) if macros[k]
                          else "") %}
      {% set outvars = [] %}
      {% if VARS %}
        {% for v in printer["gcode_macro " ~ k] | sort %}
          {% set dummy = outvars.append("\n* %s: %s" %
                           (v, printer["gcode_macro " ~ k][v]|string)) %}
        {% endfor %}
      {% endif %}
      {% set dummy = output.append(line + outvars | join("")) %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output | sort | join("\n")) }

[gcode_macro _filament_runout]
gcode:
    SET_IDLE_TIMEOUT TIMEOUT=10800 # Set idle_timeout to 3hrs
    #M104 S0 # turn off the hotend
    #SAVE_GCODE_STATE is not required as PAUSE does this automatically
    # See here: https://www.klipper3d.org/G-Codes.html#pause
    PAUSE
    G91 # Relative positioning
    G1 E-10 F2100 # Retract 10mm of filament
    G1 Z10 # Move Z up 10mm from current position
    G90 # Absolute positioning
    G1 X210 Y210 F6000 # Park at the coordinates you said you wanted
    M106 S0 # Disable the part cooling fan
    UPDATE_DELAYED_GCODE ID=runout_wait DURATION=300

[delayed_gcode runout_wait]
gcode:
    # Honestly you probably shouldn't keep the hotend heated for 5 minutes as it's
    # definitely going to leak a bunch of filament during that time, but anyway
    M104 S0 # turn off the hotend

[gcode_macro _filament_insert]
gcode:
    # Get the extruder min_extrude_temp (will be 150 if not defined)
    {% set TARGET = printer.configfile.config.extruder.min_extrude_temp|float %}
    # Get the current extruder temp
    {% set TEMP = printer.extruder.temperature|float %}
    {% if TEMP < TARGET %}
        RESPOND TYPE=error MSG="Please heat the extruder before continuing."
    {% else %}
        RESPOND TYPE=error MSG="Press RESUME to continue."
    {% endif %}
    SET_IDLE_TIMEOUT TIMEOUT=900 # Set idle_timeout to 15 minutes


# Use this macro to heat the extruder and then resume like so:
# 
# HEAT_AND_RESUME TARGET=220
# 
[gcode_macro HEAT_AND_RESUME]
description: Heat the extruder and resume print when target is reached
gcode:
    # Get the extruder min_extrude_temp (will be 150 if not defined)
    {% set min_target = printer.configfile.config.extruder.min_extrude_temp|float %}
    # Get the target from params or set it to min_target if none is given
    {% set TARGET = params.TARGET|default(min_target)|float %}
    # Heat the extruder and wait for the target to be reached
    M109 S{TARGET}
    # Notify that print is resuming
    RESPOND TYPE=error MSG="Temperature reached. Resuming print."
    # Resume print when target is reached
    # This will automatically restore to the pre-PAUSE position
    # See here: https://www.klipper3d.org/G-Codes.html#resume
    RESUME


[gcode_macro PURGE_LINE]
gcode:
    M117 Purging
    {action_respond_info("Purging...")}
    G90 ; absolute positioning
    G92 E0 ; zero/reset extruder
    G1 X2.2 Y215 Z0.3 F18000 ; move to start position
    G92 E0 ; zero/reset extruder

    G1 X200 Y215 Z0.25 F1500 E10 ; extrude the first line
    G1 X200 Y215.5 Z0.3 F18000 ; move to side a little
    G1 X2.5 Y215.5 Z0.25 F1500.0 E20 ; extrude the second line

    G92 E0 ; zero/reset extruder
    G1 E-0.1 F3000 ; move nozzle up and retract tiny bit

    G91 ; relative positioning
    G0 Z1.00 X10.0 Y-10.0 F20000 ; move nozzle to remove stringing
    G90 ; absolute positioning
    
    G92 E0 ; zero/reset extruder



# Macros for during printing

# Cancel print macro
[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
gcode:
  M400 ; wait for buffer to clear
  G92 E0 ; zero the extruder
  {% if printer[printer.toolhead.extruder].target > 220 %}
      G1 E-5.0 F3600 ; retract filament PETG
  {% else %}
      G1 E-1.0 F3600 ; retract filament PLA
  {% endif %}
  TURN_OFF_HEATERS
  CLEAR_PAUSE
    G91 ; relative positioning
  G0 Z1.00 X20.0 Y20.0 F20000 ; move nozzle to remove stringing
  TURN_OFF_HEATERS
  M107 ; turn off fan
  G1 Z4 F3000 ; move nozzle up 2mm
  G90 ; absolute positioning
  G0 X190 Y190 F3600 ; park nozzle at rear
  END_PRINT



# Enables pause/resume functionality
[gcode_macro PAUSE]
rename_existing: BASE_PAUSE
gcode:
    # Parameters
    {% set z = params.Z|default(10)|int %}                                                   ; z hop amount

    {% if printer['pause_resume'].is_paused|int == 0 %}
        SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE={z}                              ; set z hop variable for reference in resume macro
        SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=etemp VALUE={printer['extruder'].target}    ; set hotend temp variable for reference in resume macro

        #SET_FILAMENT_SENSOR SENSOR=filament_sensor ENABLE=0                                  ; disable filament sensor
        SAVE_GCODE_STATE NAME=PAUSE                                                          ; save current print position for resume
        BASE_PAUSE                                                                           ; pause print
        {% if (printer.gcode_move.position.z + z) < printer.toolhead.axis_maximum.z %}       ; check that zhop doesn't exceed z max
            G91                                                                              ; relative positioning
            G1 Z{z} F900                                                                     ; raise Z up by z hop amount
        {% else %}
            { action_respond_info("Pause zhop exceeds maximum Z height.") }                  ; if z max is exceeded, show message and set zhop value for resume to 0
            SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE=0
        {% endif %}
        G90                                                                                  ; absolute positioning
        G1 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} F6000   ; park toolhead at front center
        SAVE_GCODE_STATE NAME=PAUSEPARK                                                      ; save parked position in case toolhead is moved during the pause (otherwise the return zhop can error)
        M104 S0                                                                              ; turn off hotend
        SET_IDLE_TIMEOUT TIMEOUT=43200                                                       ; set timeout to 12 hours
    {% endif %}

[gcode_macro RESUME]
rename_existing: BASE_RESUME
variable_zhop: 0
variable_etemp: 0
gcode:
    # Parameters
    {% set e = params.E|default(2.5)|int %}                                          ; hotend prime amount (in mm)

    {% if printer['pause_resume'].is_paused|int == 1 %}
        SET_FILAMENT_SENSOR SENSOR=runout_sensor ENABLE=1                          ; enable filament sensor
        #INITIAL_RGB                                                                    ; reset LCD color
        SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}  ; set timeout back to configured value
        {% if etemp > 0 %}
            M109 S{etemp|int}                                                        ; wait for hotend to heat back up
        {% endif %}
        RESTORE_GCODE_STATE NAME=PAUSEPARK MOVE=1 MOVE_SPEED=100                     ; go back to parked position in case toolhead was moved during pause (otherwise the return zhop can error)
        G91                                                                          ; relative positioning
        M83                                                                          ; relative extruder positioning
        {% if printer[printer.toolhead.extruder].temperature >= printer.configfile.settings.extruder.min_extrude_temp %}
            G1 Z{zhop * -1} E{e} F900                                                ; prime nozzle by E, lower Z back down
        {% else %}
            G1 Z{zhop * -1} F900                                                     ; lower Z back down without priming (just in case we are testing the macro with cold hotend)
        {% endif %}
        RESTORE_GCODE_STATE NAME=PAUSE MOVE=1 MOVE_SPEED=60                          ; restore position
        BASE_RESUME                                                                  ; resume print
    {% endif %}

[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
gcode:
    SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout} ; set timeout back to configured value
    CLEAR_PAUSE
    SDCARD_RESET_FILE
    PRINT_END
    BASE_CANCEL_PRINT

    
[gcode_macro m600]
description: Pauses the current print.
  Usage: M600 [B<beeps>] [E<pos>] [L<pos>] [R<temp>] [U<pos>] [X<pos>] [Y<pos>] [Z<pos>]
  
gcode:
  PAUSE B="{0}" P=2{% for k in params|select("in", "EXYZ") %}{
      ' '~k~'="'~params[k]~'"'}{% endfor %}
  UNLOAD_FILAMENT{% if 'U' in params %} LENGTH={params.U}{% endif
               %} BEEPS="{params.B|default(10)|int}"
  {% if 'R' in params %}M109 S{params.R}{% endif %}

[gcode_macro m601]
description: Pauses the current print.
  Usage: M601
gcode:
  PAUSE

[gcode_macro m602]
description: Resumes the currently paused print.
  Usage: M602
gcode:
  RESUME

[gcode_macro m24]
rename_existing: M24.6245197
gcode:
  {% if printer.pause_resume.is_paused %}
  RESUME
  {% else %}
  M24.6245197
  {% endif %}

[gcode_macro m25]
rename_existing: M25.6245197
gcode:
  PAUSE


[gcode_macro DUMP_VARIABLES]
gcode:
    {% set filter_name = params.NAME|default('')|string|lower %}
    {% set filter_value = params.VALUE|default('')|string|lower %}
    {% set show_cfg = params.SHOW_CFG|default(0)|int %}
    
    {% set out = [] %}

    {% for key1 in printer %}
        {% for key2 in printer[key1] %}
            {% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
                {% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
            {% endif %}
        {% else %}
            {% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
                {% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
            {% endif %}
        {% endfor %}
    {% endfor %}
    
    {action_respond_info(out|join("\n"))}


[gcode_macro TEST_SPEED]
# Home, get position, throw around toolhead, home again.
# If MCU stepper positions (first line in GET_POSITION) are greater than a full step different (your number of microsteps), then skipping occured.
# We only measure to a full step to accomodate for endstop variance.
# Example: TEST_SPEED SPEED=300 ACCEL=5000 ITERATIONS=10

description: Test for max speed and acceleration parameters for the printer. Procedure: Home -> ReadPositionFromMCU -> MovesToolhead@Vel&Accel -> Home -> ReadPositionfromMCU

gcode:
    # Speed
    {% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
    # Iterations
    {% set iterations = params.ITERATIONS|default(5)|int %}
    # Acceleration
    {% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
    # Minimum Cruise Ratio
    {% set min_cruise_ratio = params.MIN_CRUISE_RATIO|default(0.5)|float %}
    # Bounding inset for large pattern (helps prevent slamming the toolhead into the sides after small skips, and helps to account for machines with imperfectly set dimensions)
    {% set bound = params.BOUND|default(20)|int %}
    # Size for small pattern box
    {% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
    
    # Large pattern
        # Max positions, inset by BOUND
        {% set x_min = printer.toolhead.axis_minimum.x %}
        {% if x_min < 0 %}
            {% set x_min = 0 %}
        {% endif %}
    
        {% set y_min = printer.toolhead.axis_minimum.y %}
        {% if y_min < 0 %}
            {% set y_min = 0 %}
        {% endif %}
    
        {% set x_min = x_min + bound %}
        {% set x_max = printer.toolhead.axis_maximum.x - bound %}
        {% set y_min = y_min + bound %}
        {% set y_max = printer.toolhead.axis_maximum.y - bound %}
    
    # Small pattern at center
        # Find X/Y center point
        {% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
        {% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
        
        # Set small pattern box around center point
        {% set x_center_min = x_center - (smallpatternsize/2) %}
        {% set x_center_max = x_center + (smallpatternsize/2) %}
        {% set y_center_min = y_center - (smallpatternsize/2) %}
        {% set y_center_max = y_center + (smallpatternsize/2) %}

    # Save current gcode state (absolute/relative, etc)
    SAVE_GCODE_STATE NAME=TEST_SPEED
    
    # Output parameters to g-code terminal
    { action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }
    
    # Home and get position for comparison later:
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28
        # QGL if not already QGLd (only if QGL section exists in config)
        {% if printer.configfile.settings.quad_gantry_level %}
            {% if printer.quad_gantry_level.applied == False %}
                QUAD_GANTRY_LEVEL
                G28 Z
            {% endif %}
        {% endif %} 
        # Move 50mm away from max position and home again (to help with hall effect endstop accuracy - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/24)
        G90
        G1 X{printer.toolhead.axis_maximum.x-50} Y{printer.toolhead.axis_maximum.y-50} F{30*60}
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28 X Y
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Go to starting position
    G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}

    # Set new limits
    {% if printer.configfile.settings.printer.minimum_cruise_ratio is defined %}
        SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} MINIMUM_CRUISE_RATIO={min_cruise_ratio}
    {% else %}
        SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}
    {% endif %}

    {% for i in range(iterations) %}
        # Large pattern diagonals
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_max} Y{y_max} F{speed*60}
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
        G0 X{x_min} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
        
        # Large pattern box
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_min} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
    
        # Small pattern diagonals
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_max} Y{y_center_max} F{speed*60}
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
        G0 X{x_center_min} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
        
        # Small pattern box
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_min} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
    {% endfor %}

    # Restore max speed/accel/accel_to_decel to their configured values
    {% if printer.configfile.settings.printer.minimum_cruise_ratio is defined %}
        SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} MINIMUM_CRUISE_RATIO={printer.configfile.settings.printer.minimum_cruise_ratio} 
    {% else %}
        SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel}
    {% endif %}

    # Re-home and get position again for comparison:
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28 # This is a full G28 to fix an issue with CoreXZ - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/12
        # Go to XY home positions (in case your homing override leaves it elsewhere)
        G90
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Restore previous gcode state (absolute/relative, etc)
    RESTORE_GCODE_STATE NAME=TEST_SPEED




[gcode_macro _CLIENT_VARIABLE]
variable_use_custom_pos   : False # use custom park coordinates for x,y [True/False]
variable_custom_park_x    : 0.0   # custom x position; value must be within your defined min and max of X
variable_custom_park_y    : 210.0   # custom y position; value must be within your defined min and max of Y
variable_custom_park_dz   : 10.0   # custom dz value; the value in mm to lift the nozzle when move to park position
variable_retract          : 20.0   # the value to retract while PAUSE
variable_cancel_retract   : 5.0   # the value to retract while CANCEL_PRINT
variable_speed_retract    : 100.0  # retract speed in mm/s
variable_unretract        : 1.0   # the value to unretract while RESUME
variable_speed_unretract  : 100.0  # unretract speed in mm/s
variable_speed_hop        : 100.0  # z move speed in mm/s
variable_speed_move       : 100.0 # move speed in mm/s
variable_park_at_cancel   : False # allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
variable_park_at_cancel_x : None  # different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
variable_park_at_cancel_y : None  # different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
## !!! Caution [firmware_retraction] must be defined in the printer.cfg if you set use_fw_retract: True !!!
variable_use_fw_retract   : False # use fw_retraction instead of the manual version [True/False]
variable_idle_timeout     : 600     # time in sec until idle_timeout kicks in. Value 0 means that no value will be set or restored
variable_runout_sensor    : "runout_sensor"    # If a sensor is defined, it will be used to cancel the execution of RESUME in case no filament is detected.
##                                   Specify the config name of the runout sensor e.g "filament_switch_sensor runout". Hint use the same as in your printer.cfg
## !!! Custom macros, please use with care and review the section of the corresponding macro.
## These macros are for simple operations like setting a status LED. Please make sure your macro does not interfere with the basic macro functions.
## Only  single line commands are supported, please create a macro if you need more than one command.
variable_user_pause_macro : "PAUSE"    # Everything inside the "" will be executed after the klipper base pause (PAUSE_BASE) function
variable_user_resume_macro: "RESUME"    # Everything inside the "" will be executed before the klipper base resume (RESUME_BASE) function
variable_user_cancel_macro: "CANCEL_PRINT"    # Everything inside the "" will be executed before the klipper base cancel (CANCEL_PRINT_BASE) function
gcode: